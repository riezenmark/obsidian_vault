---
создал заметку: 2024-07-23
tags:
  - Education
  - Programming
  - Clojure
---
Синтаксис языка Clojure состоит из использования S-выражений (сокращение от «Symbolic expression»).
![[S-Expressions.png]]
В примере выше:
- 3 и 4 выражают сами себя (long)
- + выражает функцию, которая реализует `+`
- список вызывает функцию `+` с 3 и 4 в качестве аргументов

Списки могут быть переданы в списки
```lisp
(* 2 (+ 4 5))
;;(4 + 5) * 2 = 9 * 2 = 18
```

### Деление
Деление возвращает дробь
```lisp
(/ 4 5)
;;=> 4/5
(type (/ 4 5))
;;=> clojure.lang.Ratio
```
### Сравнения
#### Equals
```
clojure.core =  
([x] [x y] [x y & more])  
 Equality. Returns true if x equals y, false if not. Same as  
 Java x.equals(y) except it also works for nil, and compares  
 numbers and collections in a type-independent manner.  Clojure's immutable data  
 structures define equals() (and thus =) as a value, not an identity,  
 comparison.
```
#### По значению
```
clojure.core ==  
([x] [x y] [x y & more])  
 Returns non-nil if nums all have the equivalent  
 value (type-independent), otherwise false
```
#### По ссылке
```
clojure.core/identical?  
([x y])  
 Tests if 2 arguments are the same object
```
### Определение переменных
```clojure
(def x 10)
```
- Можно переопределять переменные
- Можно менять тип, присваивая значения иного типа
###  Определение функций
#### Именованные
```clojure
(defn square [x]
	(* x x))
```
#### Безымянные
```clojure
(fn [x] (+ x x))

((fn [x] (+ x x)) 20)
;;40
```
#### "Переименование"
```clojure
(def mul2 (fn [x] (+ x x)))
```
#### Передача функции в качестве аргумента
```clojure
(defn twice [f] (fn [x] (f (f x))))
;;Принимает функцию и возвращает функцию, применённую 2 раза:
;;один раз к икс и второй раз к результату прменения к икс

((twice square) 3)
;;81 = ((3^2)^2)
```
### Условия
Рекурсивное вычисление n-ного числа Фибоначчи.
```clojure
(defn fib [n]
	(cond
	(== 0 n) 1
	(== 1 n) 1
	:else (+
		(fib (- n 1))
		(fib (- n 2)))))
```
### Мемоизация
Запоминание (кэширование) промежуточных значений во избежание их повторного вычисления.
```clojure
(def fib
	(memoize
		(fn [n]
			(cond
				(== 0 n) 1N
				(== 1 n) 1N
				:else (+
					(fib (- n 1))
					(fib (- n 2)))))))
```
Данная реализация функции вычисления n-ного числа Фибоначчи не пересчитывает ранее вычисленные функции от тех же аргументов.
### Хвостовая рекурсия #TODO + для Scala #TODO
```clojure
(defn iter-fib' [n a b]
	(if (== 0 n)
		a
		(recur (- n 1) b (+ a b))))

(defn iter-fib [n] (iter-fib' n 1N 1N))
```
### Локальные функции
```clojure
(defn iter-fib [n]  
  (letfn [(iter-fib' [n a b]  
            (if (== 0 n)  
              a  
              (iter-fib' (- n 1) b (+ a b))))  
          ]  
    (iter-fib' n 1N 1N)))
```
`iter-fib'` не видна в общем неймспейсе
### Специальная форма loop
На нечётных местах принимает название "переменной", на чётных местах её исходное значение
```clojure
(defn loop-fib [n]
	(loop [n' n a 1N b 1N]
	(if (== 0 n')
		a
		(recur (- n' 1) b (+ a b)))))
```


